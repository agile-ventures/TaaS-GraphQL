"""
Tezos address. Represented as public key hash (Base58Check-encoded) prefixed with tz1, tz2, tz3 or KT1.
"""
scalar Address

"""
Timestamp specified as a ISO-8601 UTC date string (2020-02-04T15:31:39Z)
"""
scalar DateTime

"""
JSON represents any valid JSON object
"""
scalar JSON

"""
Raw Michelson expression represented as JSON
"""
scalar MichelsonExpression

"""
Arbitrary precision number represented as string in JSON.
"""
scalar BigNumber

schema {
    query: Query
}

type Query {
    """
    Block fetches a Tezos block by number, hash (Base58Check-encoded) or relative pointer (head~n).
    If neither is supplied, the most recent known block (head) is returned.
    """
    block(block: String): Block

    """
    Blocks returns all blocks in a given interval, but maximum of <count> elements.
    Hash (Base58Check-encoded), level, relative pointer (head~n) and head are allowed in the "from" a "to" arguments.

    Example queries:
    blocks(from: "head~4") {...}  # return last 5 blocks
    blocks(count: 5) {...}  # return last 5 blocks
    blocks(from: "head~9", count: 5) {...}  # five blocks before them
    blocks(to: "<somehash>", count: 5) {...}  # return 5 blocks before and including <somehash>
    blocks(from: "<somehash>", count: 5) {...}  # return 5 blocks since and including <somehash>
    """
    blocks(from: String, to: String, count: Int): [Block!]!
}

"""
Tezos block. See https://tezos.gitlab.io/api/rpc.html#get-block-id
"""
type Block {
    """
    Tezos protocol ID (Base58Check-encoded)
    """
    protocol: String!

    """
    The network identifier (Base58Check-encoded)
    """
    chainId: String!

    """
    The block's unique identifier (Base58Check-encoded)
    """
    hash: String!

    """
    Associated header object.
    """
    header: BlockHeader!

    """
    Associated metadata object.
    """
    metadata: BlockMetadata!

    """
    Returns the delegate with the given address, or null
    """
    delegate(address: Address!): Delegate

    """
    Returns the constants
    """
    constants: Constants!

    """
    Returns the contract with the given address, or null
    """
    contract(address: Address): Contract

    """
    Returns the operation entry with the given hash, or null
    """
    operation(hash: String!): OperationEntry

    """
    All operations in this block as returned from the Tezos node
    """
    operations: [[OperationEntry]]

    """
    Returns activations from block. Results can be filtered by operation hash, or address (pkh)
    """
    activations(hash: String, address: Address): [ActivateAccount!]!

    """
    Returns ballots from block. Results can be filtered by operation hash, source, proposal or vote (ballot).
    """
    ballots(hash: String, source: Address, proposal: String, ballot: BallotVote): [Ballot!]!

    """
    Returns delegations from block. Results can be filtered by operation hash, source, delegate or operation result status.
    """
    delegations(hash: String, source: Address, delegate: Address, status: OperationResultStatus): [Delegation!]!

    """
    Returns double baking evidence from block. Results can be filtered by operation hash or delegate.
    """
    doubleBakingEvidence(hash: String, delegate: Address): [DoubleBakingEvidence!]!

    """
    Returns double endorsement evidence from block. Results can be filtered by operation hash or delegate.
    """
    doubleEndorsementEvidence(hash: String, delegate: Address): [DoubleEndorsementEvidence!]!

    """
    Returns endorsements from block. Results can be filtered by operation hash, or delegate.
    """
    endorsements(hash: String, delegate: Address): [Endorsement!]!

    """
    Returns originations from block. Results can be filtered by
    operation hash, source, delegate, originated contract or operation result status.
    """
    originations(hash: String, source: Address, delegate: Address, originatedContract: Address, status: OperationResultStatus): [Origination!]!

    """
    Returns proposals from block. Results can be filtered by operation hash, source or proposal hash.
    """
    proposals(hash: String, source: Address, proposal: String): [Proposals!]!

    """
    Returns reveals from block. Results can be filtered by operation hash, source or operation result status.
    """
    reveals(hash: String, source: Address, status: OperationResultStatus): [Reveal!]!

    """
    Returns seed nonce revelations from block. Results can be filtered by operation hash, source or operation result status.
    """
    seedNonceRevelations(hash: String, delegate: Address): [SeedNonceRevelation!]!

    """
    Returns transactions from block. Results can be filtered by operation hash, source, destination or operation result status.
    """
    transactions(hash: String, source: Address, destination: Address, status: OperationResultStatus): [Transaction!]!
}

"""
A block header. See https://tezos.gitlab.io/api/rpc.html#get-block-id-header
"""
type BlockHeader {
    level: Int!
    proto: Int!
    predecessor: String!
    timestamp: DateTime!
    validationPass: Int!
    operationsHash: String
    fitness: [String!]!
    context: String!
    priority: Int!
    proofOfWorkNonce: String!
    seedNonceHash: String
    signature: String!
}

"""
Block metadata. See https://tezos.gitlab.io/api/rpc.html#get-block-id-metadata
"""
type BlockMetadata {
    protocol: String!
    nextProtocol: String!
    testChainStatus: TestChainStatus!
    maxOperationsTtl: Int!
    maxOperationDataLength: Int!
    maxBlockHeaderLength: Int!
    maxOperationListLength: [MaxOperationListLength!]
    baker: Address!
    level: Level!
    votingPeriodKind: String!
    nonceHash: String
    consumedGas: BigNumber
    deactivated: [Address!]
    balanceUpdates: [BalanceUpdate!]
}

"""
Contains information about the block's level.
"""
type Level {
    """
    The level of the block relative to genesis. This is also the Shell's notion of level
    """
    level: Int!

    """
    The level of the block relative to the block that starts protocol alpha
    """
    levelPosition: Int!

    """
    The current cycle's number. Note that cycles are a protocol-specific notion. As a result, the cycle number starts at 0 with the first block of protocol alpha.
    """
    cycle: Int!

    """
    The current level of the block relative to the first block of the current cycle.
    """
    cyclePosition: Int!

    """
    The current voting period's index. Note that cycles are a protocol-specific notion. As a result, the voting period index starts at 0 with the first block of protocol alpha.
    """
    votingPeriod: Int!

    """
    The current level of the block relative to the first block of the current voting period.
    """
    votingPeriodPosition: Int!

    """
    Tells whether the baker of this block has to commit a seed nonce hash.
    """
    expectedCommitment: Boolean!
}

"""
Status of the test chain
"""
type TestChainStatus {
    """
    The status value: notRunning (there is no test chain at the moment), forking (the test chain is being setup),
    running (the test chain is running).
    """
    status: String!
}

type MaxOperationListLength {
    maxSize: Int!
    maxOp: Int
}

enum BalanceUpdateKind {
    CONTRACT
    FREEZER
}

enum BalanceUpdateCategory {
    DEPOSITS
    FEES
    REWARDS
}

"""
Everything about a delegate. See https://tezos.gitlab.io/api/rpc.html#get-block-id-context-delegates-pkh
"""
type Delegate {
    """
    The full balance of a given delegate, including the frozen balances.
    """
    balance: BigNumber!

    """
    The total frozen balances of a given delegate, this includes the frozen deposits, rewards and fees.
    """
    frozenBalance: BigNumber!

    """
    Returns the frozen balances of a given delegate, indexed by the cycle by which it will be unfrozen.
    """
    frozenBalanceByCycle: [FrozenBalanceByCycle!]!

    """
    The total amount of tokens delegated to a given delegate. This includes the balances of all the contracts that delegate to it,
    but also the balance of the delegate itself and its frozen fees and deposits. The rewards do not count in the delegated balance until they are unfrozen.
    """
    stakingBalance: BigNumber!

    """
    The list of contracts that delegate to a given delegate.
    """
    delegatedContracts: [String!]!

    """
    The balances of all the contracts that delegate to a given delegate. This excludes the delegate's own balance and its frozen balances.
    """
    delegatedBalance: BigNumber!

    """
    Tells whether the delegate is currently tagged as deactivated or not.
    """
    deactivated: Boolean!

    """
    The cycle by the end of which the delegate might be deactivated if she fails to execute any delegate action. A deactivated delegate might be reactivated
    (without loosing any rolls) by simply re-registering as a delegate. For deactivated delegates, this value contains the cycle by which they were deactivated.
    """
    gracePeriod: Int!

    """
    Returns baking rights for a delegate or null. Results can be filtered by maxPriority, level or cycle. If maxPriority parameter is empty, server will default to the ENV value TEZOS_BAKING_RIGHTS_MAX_PRIORITY.
    """
    bakingRights(maxPriority: Int, level: [Int], cycle: [Int]): [BakingRight]

    """
    Returns endorsing rights for a delegate or null. Results can be filtered by level or cycle.
    """
    endorsingRights(level: [Int], cycle: [Int]): [EndorsingRight]
}

type BakingRight {
    level: Int!
    delegate: String!
    priority: Int!

    """
    Omitted for levels in the past, and only an estimate for levels later that the next block, based on the hypothesis that all predecessor blocks were baked at the first priority.
    """
    estimatedTime: DateTime
}

type EndorsingRight {
    level: Int!
    delegate: String!
    slots: [Int]!

    """
    Omitted for levels in the past, and only an estimate for levels later that the next block, based on the hypothesis that all predecessor blocks were baked at the first priority.
    """
    estimatedTime: DateTime
}

"""
Frozen balance of a given delegate, indexed by the cycle by which it will be unfrozen
"""
type FrozenBalanceByCycle {
    cycle: Int!
    deposit: BigNumber!
    fees: BigNumber!
    rewards: BigNumber!
}

"""
All constants
"""
type Constants {
    proofOfWorkNonceSize: Int
    nonceLength: Int
    maxRevelationsPerBlock: Int
    maxOperationDataLength: Int
    maxProposalsPerDelegate: Int
    preservedCycles: Int
    blocksPerCycle: Int
    blocksPerCommitment: Int
    blocksPerRollSnapshot: Int
    blocksPerVotingPeriod: Int
    timeBetweenBlocks: [BigNumber]
    endorsersPerBlock: Int
    hardGasLimitPerOperation: BigNumber
    hardGasLimitPerBlock: BigNumber
    proofOfWorkThreshold: BigNumber
    tokensPerRoll: BigNumber
    michelsonMaximumTypeSize: Int
    seedNonceRevelationTip: BigNumber
    originationSize: Int
    blockSecurityDeposit: BigNumber
    endorsementSecurityDeposit: BigNumber
    bakingRewardPerEndorsement: [BigNumber]
    endorsementReward: [BigNumber]
    costPerByte: BigNumber
    hardStorageLimitPerOperation: BigNumber
    testChainDuration: BigNumber
    quorumMin: Int
    quorumMax: Int
    minProposalQuorum: Int
    initialEndorsers: Int
    delayPerMissingEndorsement: BigNumber
    """
    Pre Carthaganet
    """
    blockReward: BigNumber
}

"""
Information about a smart contract.
"""
type Contract {
    """
    The unique address (public key hash).
    """
    address: String!

    """
    The balance of the contract.
    """
    balance: BigNumber!

    """
    Script belonging to the contract.
    """
    script: ScriptedContracts

    """
    The counter of the contract, if any
    """
    counter: BigNumber

    """
    Entrypoint information of the contract
    """
    entrypoints: Entrypoints

    """
    The delegate of the contract, if any
    """
    delegate: String

    """
    The manager of the contract.
    """
    managerKey: ManagerKey

    """
    Storage in Michelson format.
    """
    storage: MichelsonExpression

    """
    Decoded version of the storage.
    """
    storageDecoded: JSON

    """
    JSON representation of the storage schema.
    """
    schema: JSON

    """
    Returns the value stored for a given key in a big map owned by this contract. If a map ID is given, the keyType argument is also required.
    """
    bigMapValue(key: String!, keyType: BigMapKeyType, bigMapId: Int): MichelsonExpression

    """
    Returns the decoded value stored for a given key in this contract's big map. Note that this is only supported for the contracts originated
    with the "one bigMap per contract" scheme. Babylon protocol introduced multiple bigmaps per contract, which cannot be accessed using this field.
    """
    bigMapValueDecoded(key: String!): JSON
}

"""
One of the currently supported key types used for fetching bigMap values.
"""
enum BigMapKeyType {
    STRING
    NAT
    INT
    BYTES
    BOOL
    MUTEZ
    ADDRESS
    KEY_HASH
}

"""
Manager of a contract.
"""
type ManagerKey {
    """
    The public key
    """
    key: String!

    """
    Validity flag
    """
    invalid: Boolean
}

"""
Information about entrypoints in a contract.
"""
type Entrypoints {
    """
    List of entrypoints
    """
    entrypoints: JSON!

    unreachable: [EntrypointUnreachable!]
}

type EntrypointUnreachable {
    path: [String!]!
}

"""
Code and storage a contract
"""
type ScriptedContracts {
    """
    The code of the script
    """
    code: [MichelsonExpression!]!

    """
    The current storage value in Michelson format
    """
    storage: MichelsonExpression!
}

type OperationEntry {
    info: OperationEntryInfo!
    contents: [OperationContents!]!
}

type OperationEntryInfo {
    protocol: String!
    chainId: String!
    hash: String!
    branch: String!
    signature: String
}

interface OperationContents {
    kind: OperationKind!
    operation: OperationEntryInfo!
}

enum OperationKind {
    ACTIVATE_ACCOUNT
    BALLOT
    DELEGATION
    DOUBLE_BAKING_EVIDENCE
    DOUBLE_ENDORSEMENT_EVIDENCE
    ENDORSEMENT
    ORIGINATION
    PROPOSALS
    REVEAL
    SEED_NONCE_REVELATION
    TRANSACTION
}

type Endorsement implements OperationContents {
    # kind is always 'endorsement'
    kind: OperationKind!
    level: Int!
    metadata: EndorsementMetadata!
    operation: OperationEntryInfo!
}

type EndorsementMetadata {
    balanceUpdates: [BalanceUpdate!]!
    delegate: Address!
    slots: [Int!]!
}

type SeedNonceRevelation implements OperationContents {
    # kind is always 'seedNonceRevelation'
    kind: OperationKind!
    level: Int!
    nonce: String!
    metadata: OperationContentMetadata!
    operation: OperationEntryInfo!
}

type DoubleEndorsementEvidence implements OperationContents {
    # kind is always 'doubleEndorsementEvidence'
    kind: OperationKind!
    op1: InlinedEndorsement!
    op2: InlinedEndorsement!
    metadata: OperationContentMetadata!
    operation: OperationEntryInfo!
}

type InlinedEndorsement {
    branch: String!
    operations: InlinedEndorsementContents!
    signature: String
}

type InlinedEndorsementContents {
    # kind is always 'endorsement'
    kind: OperationKind!
    level: Int!
}

type OperationContentMetadata {
    balanceUpdates: [BalanceUpdate!]!
}

type DoubleBakingEvidence implements OperationContents {
    # kind is always 'doubleBakingEvidence'
    kind: OperationKind!
    bh1: BlockHeader!
    bh2: BlockHeader!
    metadata: OperationContentMetadata!
    operation: OperationEntryInfo!
}

type ActivateAccount implements OperationContents {
    # kind is always 'activateAccount'
    kind: OperationKind!
    pkh: String!
    secret: String!
    metadata: OperationContentMetadata!
    operation: OperationEntryInfo!
}

type Reveal implements OperationContents {
    # kind is always 'reveal'
    kind: OperationKind!
    source: Address!
    fee: BigNumber!
    counter: String!
    gasLimit: BigNumber!
    storageLimit: BigNumber!
    publicKey: String!
    metadata: RevealMetadata!
    operation: OperationEntryInfo!
}

type RevealMetadata {
    balanceUpdates: [BalanceUpdate!]!
    internalOperationResults: [InternalOperationResult!]
    operationResult: RevealOperationResult!
}

type RevealOperationResult implements OperationResult {
    status: OperationResultStatus!
    consumedGas: BigNumber
    errors: [OperationError!]
}

type Transaction implements OperationContents {
    # kind is always 'transaction'
    kind: OperationKind!
    source: Address!
    fee: BigNumber!
    counter: BigNumber!
    gasLimit: BigNumber!
    storageLimit: BigNumber!
    amount: BigNumber!
    destination: String!
    parameters: MichelsonExpression
    metadata: TransactionMetadata!
    operation: OperationEntryInfo!
}

type TransactionMetadata {
    balanceUpdates: [BalanceUpdate!]!
    operationResult: TransactionOperationResult!
    internalOperationResults: [InternalOperationResult!]
}

type TransactionOperationResult implements OperationResult {
    status: OperationResultStatus!
    consumedGas: BigNumber
    errors: [OperationError!]
    storage: MichelsonExpression
    bigMapDiff: [BigMapDiffItem!]
    balanceUpdates: [BalanceUpdate!]
    originatedContracts: [String!]
    storageSize: String
    paidStorageSizeDiff: String
    allocatedDestinationContract: Boolean
}

type BigMapDiffItem {
    keyHash: String!
    key: MichelsonExpression!
    value: MichelsonExpression
}

type Delegation implements OperationContents {
    # kind is always 'delegation'
    kind: OperationKind!
    source: Address!
    fee: BigNumber!
    counter: BigNumber!
    gasLimit: BigNumber!
    storageLimit: BigNumber!
    delegate: Address
    metadata: DelegationMetadata!
    operation: OperationEntryInfo!
}

type DelegationMetadata {
    balanceUpdates: [BalanceUpdate!]!
    operationResult: DelegationOperationResult!
    internalOperationResults: [InternalOperationResult!]
}

type DelegationOperationResult implements OperationResult {
    status: OperationResultStatus!
    consumedGas: BigNumber
    errors: [OperationError!]
}

type Origination implements OperationContents {
    # kind is always 'origination'
    kind: OperationKind!
    source: Address!
    fee: BigNumber!
    counter: BigNumber!
    gasLimit: BigNumber!
    storageLimit: BigNumber!
    balance: BigNumber!
    delegate: Address
    script: ScriptedContracts
    metadata: OriginationMetadata!
    operation: OperationEntryInfo!
}

type OriginationMetadata {
    balanceUpdates: [BalanceUpdate!]!
    operationResult: OriginationOperationResult!
    internalOperationResults: [InternalOperationResult!]
}

type OriginationOperationResult implements OperationResult {
    status: OperationResultStatus!
    consumedGas: BigNumber
    errors: [OperationError!]
    balanceUpdates: [BalanceUpdate!]
    originatedContracts: [String!]
    storageSize: BigNumber
    paidStorageSizeDiff: BigNumber
}

type Proposals implements OperationContents {
    # kind is always 'proposals'
    kind: OperationKind!
    source: Address!
    period: Int!
    proposals: [String!]!
    metadata: JSON
    operation: OperationEntryInfo!
}

type Ballot implements OperationContents {
    # kind is always 'ballot'
    kind: OperationKind!
    source: Address!
    period: Int!
    proposal: String!
    ballot: BallotVote!
    metadata: JSON
    operation: OperationEntryInfo!
}

enum BallotVote {
    NAY
    PASS
    YAY
}

type BalanceUpdate {
    kind: BalanceUpdateKind!
    category: BalanceUpdateCategory
    contract: String
    delegate: Address
    cycle: Int
    change: BigNumber!
}

type InternalOperationResult {
    kind: InternalOperationKind!
    source: Address!
    nonce: Int!
    amount: BigNumber
    destination: String
    parameters: TransactionOperationParameter
    publicKey: String
    balance: BigNumber
    delegate: Address
    script: ScriptedContracts
    result: OperationResult!
}

enum InternalOperationKind {
    DELEGATION
    ORIGINATION
    REVEAL
    TRANSACTION
}

type TransactionOperationParameter {
    entrypoint: String!
    value: MichelsonExpression!
}

interface OperationResult {
    status: OperationResultStatus!
    consumedGas: BigNumber
    errors: [OperationError!]
}

enum OperationResultStatus {
    APPLIED
    BACKTRACKED
    FAILED
    SKIPPED
}

type OperationError {
    kind: String!
    id: String!
}
